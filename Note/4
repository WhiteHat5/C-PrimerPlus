배열의 크기는 상수나 const변수만 사용할 수 있다(컴파일 시점에서 값이 알려져 있다)
단, new를 이용하면 이 규칙에서 벗어날 수 있는데 나중에 알려준다 함

배열에 sizeof 연산자를 사용하면 배열의 전체 크기(바이트 단위)가 반환된다

배열을 초기화할 때 배열의 원소보다 적게 초기화 값을 주면 나머지 값들이 모두 0으로 설정된다
배열을 초기화할 때 길이를 명시하지 않으면 초기화배열의 길이로 길이가 설정된다

C++11에서는 배열을 초기화할 때 =가 없어도 된다
{}를 비워 두면 자동으로 모두 0으로 초기화된다
초기화 할 때 narrowing 이 불가능하다 (예를 들어 float가 int 배열에 저장되는 게 불가능하다)

두 string literal 이 white space로 구분되어 나타날 때 두 string은 함께 묶여서 해석된다
cout << "This statem" "ent will be concat" 
"enated into one sentence.";

cin.getline() 으로 getline 멤버함수를 호출한다
getline 함수는 문자열을 저장할 배열, 문자열의 최대 길이, 2개의 정보를 인자로 받는다 (will discuss optional third argument in CH17)
getline함순는 newline character를 읽거나 문자열의 최대 길이에 도달할 때까지 인풋을 읽어낸다 (개행문자는 널 문자로 변환되어 저장된다)

get()은 getline()과 다르게 대기열에 개행문자를 남겨놓기 때문에 다음번에 호출될 때 이 개행문자를 읽어들이게 된다.
이를 막기 위해 인자 없이 cin.get()을 사용해서 개행문자를 버퍼에서 지울 수 있다.

get 과 getline이 멤버 함수이고 cin 객체를 반환하기 때문에 다음과 같은 활용이 가능하다:
cin.get(name, ArSize).get(); // name을 읽어들이는 코드와 남아있는 개행문자를 읽어들이는 코드를 합쳤다
get과 getline을 비교해보았을 때 getline은 조금 더 단순하다는 장점이 있다.
get의 경우 개행문자를 남기기 때문에 함수가 호출된 후 버퍼에 남겨져 있는 첫 문자가 개행문자인지 검사하여 함수가 올바르게 모든 입력을 읽었는지 확인할 수 있다.

get()의 경우 empty line을 읽어들이면 failbit을 남기고 이후 입력을 막는다. (cin.clear()로 이후 입력을 이어갈 수 있다)
getline()의 경우 입력 문자열이 할당된 공간보다 크면 failbit을 남기고 이후 입력을 막는다
*) cin >> year; 숫자를 입력받는 코드는 개행문자를 남기므로 다음과 같은 방법으로 개행문자를 없앤다:
cin.get(); //코드 뒤에 get을 호출한다
(cin >> year).get(); // 코드가 cin 객체를 반환한다는 것을 이용하여 get호출을 한 줄에 입력한다

string 클래스를 쓰려면 string 헤더파일을 포함시키고 std 네임스페이스를 사용해야 한다 (using을 사용하거나 std::string으로 명시)
string 객체는 배열이 아닌 단순 객체처럼 선언할 수 있다
스트링 객체는 저장하는 문자열의 길이에 따라 크기가 자동으로 조정된다

C++에서는 문자열의 list-style initialization 을 허용한다
string third_date {"Hank's Fine Eats"};

string 객체는 배열로 표현된 문자열과 달리 1대1 할당이 가능하다
str1 = str2; //str2의 값을 str1으로 복사
또한 +연산자로 두 문자열을 이어붙일 수도 있다
str3 = str1 + str2; // str1과 str2를 이어붙인 값을 str3에 할당한다

*) str1.size() // str1의 크기를 반환하는 메소드 (strlen과 같은 역할)
기존 C에서도 strcpy, strcat 등의 함수들이 있었지만 string 객체의 장점은 특별히 크기를 명시하지 않아도 메모리를 자동으로 지정해준다는 데에 있다
strncpy, strncat 처럼 메모리 초과방지를 위해 세번째 인자를 추가한 함수들보다 훨씬 간단하게 메모리 관련 버그를 방지할 수 있다

!) string 객체에 getline으로 문자열을 받아들이려면 다른 syntax를 써야 한다
getline(cin, str); // cin.getline()이 아님에 유의
cin.getline이 아닌 이유는 istream 클래스가 나온 후에 string 클래스가 생겼기 때문 (그런데 cout 등으로 출력하는 건 왜 되냐면 나중에 설명해 준다 함... CH11)

wchar_t, char16_t, char32_t 타입 배열에 문자열을 저장할 수도 있다
위 타입의 문자열은 각각 L,u,U prefix를 붙여 구분한다
*) u8 prefix로 UTF-8 문자열을 구분한다

raw string은 "(, )" 로 감싸고 R prefix를 붙인다
R"(Jim "KING" uses \n instead of endl.)" // escape sequence와 "이 모두 무시된다
*) raw string 의 시작하는 "와 ( 사이에 문자들을 넣을 수 있다 (대신 끝날 떄도 같은 순서로 같은 문자들을 넣어야 raw string이 완성된다) (괄호나 역슬래시 또는 공백문자들은 해당 안됨)
이걸 이용해서 raw string 안에 "()" 를 넣을 수 있다
R"*+(  "(This sentence will be displayed with bracket AND quotation mark)"  )*+" // "*+( ~ )*+"  형태의 raw string

R과 L,u,U prefix를 합쳐서 쓸 수 있다 (순서 상관 없음: RL, uR 등)

구조체는 여러가지 다른 타입을 하나의 유닛에 담을 수 있다
C와 달리 구조체 선언 후 구조체 변수를 선언할 때 struct 키워드를 생략할 수 있다
struct inflatable {~}; // inflatable 구조체 선언
inflatable vincent; // struct inflatable 이라고 안 해도 됨
structure 멤버는 .연산자를 이용해 접근 가능하다 (클래스의 멤버 함수들에 접근하는 방식이 여기서 따온 것임)

structure을 함수 밖에서 선언하면 external declaration이 되어 이후 나오는 함수들에서 모두 사용할 수 있다
반대로 함수 안에서 선언하면 local declaration으로 그 함수 내에서만 사용할 수 있다
*) 외부변수 선언은 주로 추천되지 않는 것과 반대로 외부 구조체 선언은 권장된다
구조체의 선언은 {} 안에 ,로 구분된 구조체 멤버들을 넣어서 할 수 있다
C++11에서는 {}만 사용해서 list-style initialization이 가능하고 {}를 비워두면 모든 멤버가 0으로 초기화된다
inflatable mayor {}; // inflatable 타입 구조체 mayor를 선언하고 0으로 초기화했다

assignment operator = 를 사용하여 구조체를 다른 구조체에 할당할 수 있다
이것을 memberwise assignment라고 하며 할당하는 구조체의 모든 멤버 값이 복사되어 할당된다 (배열이 멤버여도 성립함)

구조체 선언을 할 때 구조체의 이름을 생략함으로써 general name을 포기할 수 있다 (이러한 방식은 다음에 같은 구조의 구조체를 사용할 때 다시 선언해야 하게 만듬)
struct
{
	int x;
	int y;
} position; // 구조체가 생성되었으나 구조체 타입은 일반적으로 정의되지 않았기 때문에 다음에 같은 구조를 쓰려면 재선언을 해야 함
*) C++구조체는 멤버 변수 외에도 멤버함수를 사용할 수 있지만 이런 방식은 클래스에서 더 많이 사용되므로 다음에 다루겠다고 함

구조체의 배열은 모든 원소의 타입이 구조체이다
배열의 subscripting과 구조체의 멤버 접근을 사용하여 데이터에 접근할 수 있다




